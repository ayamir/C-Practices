#include <iostream>
#include <type_traits>

class Base {
public:
  int value1;
  int value2;
  Base() { value1 = 1; }
  // 委托构造
  Base(int value) : Base() { value2 = value; }
};

class Subclass : public Base {
public:
  // 继承构造
  using Base::Base;
};

struct BaseStru {
  virtual void foo();
};

struct SubStru : BaseStru {
  // [tradition] override virtual function implicitly
  void foo();
};

struct BaseStruModern {
  virtual void foo(int);
};

struct SubStruModern : BaseStruModern {
  // [moodern] override virtual function explicitly
  virtual void foo(int) override;
  // ERROR
  // virtual void foo(float) override;
};

struct BaseFinal {
  virtual void foo() final;
};

struct SubStru1 final : BaseFinal {};

// struct SubStru2 : SubStru1 {}; Final inherit

struct SubStru3 : BaseFinal {
  //  void foo(); Final inherit
};

class Magic {
public:
  // Use constructor generated by compiler explicitly
  Magic() = default;
  // Refuse constructor generated by compiler explicitly
  Magic &operator=(const Magic &) = delete;
  Magic(int magic_number);
};

// 强类型枚举
enum class new_enum : unsigned int {
  value1,
  value2,
  value3 = 100,
  value4 = 100,
};

template <typename T>
std::ostream &operator<<(
    typename std::enable_if<std::is_enum<T>::value, std::ostream>::type &stream,
    const T &e) {
  return stream << static_cast<typename std::underlying_type<T>::type>(e);
}

int main(int argc, char *argv[]) {
  Base b(2);
  std::cout << b.value1 << " " << b.value2 << std::endl;

  Subclass s(3);
  std::cout << s.value1 << " " << s.value2 << std::endl;

  if (new_enum::value3 == new_enum::value4) {
    std::cout << "new_enum::value3 == new_enum::value4" << std::endl;
  }
  std::cout << new_enum::value3 << std::endl;
}
